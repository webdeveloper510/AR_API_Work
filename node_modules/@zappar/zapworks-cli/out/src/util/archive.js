"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const archiver = require("archiver");
const chalk_1 = require("chalk");
const fs = require("promise-fs");
const tmp = require("tmp");
const fs_dfs_1 = require("./fs-dfs");
const cliProgress = require('cli-progress');
class Archive extends fs_dfs_1.default {
    constructor(path) {
        super(path, ['index.html', 'index.htm']);
        this.displayProgress = (processed, totalNumberOfFiles) => {
            if (processed === 1) {
                this.progressBar.start(totalNumberOfFiles, 0);
            }
            this.progressBar.update(processed);
        };
        this.isEmpty = (path) => {
            let isEmpty = false;
            try {
                isEmpty = fs.readdirSync(path).length === 0;
            }
            catch (e) {
                isEmpty = true;
            }
            return isEmpty;
        };
        this.getAllDirFiles = (dirPath, arrayOfFiles) => {
            const files = fs.readdirSync(dirPath);
            let directories = 0;
            arrayOfFiles = arrayOfFiles || [];
            files.forEach((file) => {
                if (fs.statSync(`${dirPath}/${file}`).isDirectory()) {
                    directories += 1;
                    arrayOfFiles = this.getAllDirFiles(`${dirPath}/${file}`, arrayOfFiles).files;
                }
                else {
                    arrayOfFiles.push(file);
                }
            });
            return {
                files: arrayOfFiles,
                directories,
            };
        };
        this.directory = path;
        this.tmpobj = tmp.fileSync({ prefix: 'zappar-', postfix: '.zip' });
        this.progressBar = new cliProgress.Bar({
            format: `Compressing |${(0, chalk_1.cyan)('{bar}')}| {percentage}% | ETA: {eta}s | {value}/{total}`,
        }, cliProgress.Presets.rect);
    }
    async zip() {
        return new Promise((resolve, reject) => {
            if (this.isEmpty(this.directory)) {
                reject((0, chalk_1.red)('Invalid Path'));
                return;
            }
            const { directories, files } = this.getAllDirFiles(this.directory, []);
            const totalNumberOfFiles = directories + files.length;
            const output = fs.createWriteStream(`${this.tmpobj.name}`);
            const archive = archiver('zip', { zlib: { level: 9 } });
            archive.on('warning', (warn) => console.log((0, chalk_1.yellow)(warn)));
            archive.on('error', (err) => reject((0, chalk_1.red)(err)));
            archive.on('progress', (p) => this.displayProgress(p.entries.processed, totalNumberOfFiles));
            archive.directory(this.directory, false);
            output.on('close', () => {
                this.progressBar.stop();
                console.log('');
                resolve(output.path);
            });
            archive.pipe(output);
            archive.finalize();
        });
    }
    destroy() {
        this.tmpobj.removeCallback();
    }
}
exports.default = Archive;

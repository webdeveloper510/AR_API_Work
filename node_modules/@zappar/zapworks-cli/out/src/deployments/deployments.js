"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.publish = exports.upload = void 0;
const fs = require("fs");
const path = require("path");
const chalk_1 = require("chalk");
const zwClient_1 = require("./zwClient");
const archive_1 = require("../util/archive");
class DeploymentsManager extends zwClient_1.default {
    constructor(project) {
        super();
        this.project = project;
        this.upload = async () => {
            const archive = new archive_1.default(path.join(process.cwd(), this.project.directory));
            this.project.zipPath = await archive.zip();
            this.packagekey = await this.uploadCDN(fs.readFileSync(this.project.zipPath));
            try {
                const createVersionSettings = {
                    projectId: this.project.id,
                    projectVersion: this.project.version,
                    packagekey: this.packagekey,
                    enableCrossOriginIsolation: this.project.enableCrossOriginIsolation,
                };
                const resp = await this.createUAVersion(createVersionSettings);
                console.log(`${(0, chalk_1.green)('Success')} ðŸš€ Project uploaded to: ${resp.created.url}`);
            }
            catch (e) {
                const error = this.parseErrorJSON(e.message);
                switch (error.code) {
                    case 10:
                        console.log(`Version ${this.project.version} already exists. Skipped creation`);
                        break;
                    default:
                        console.log((`${(0, chalk_1.red)('ERROR cannot create version : ')}${error.errorDescription}`));
                        break;
                }
                throw new Error(`Unable to upload: ${error.errorDescription}`);
            }
            finally {
                archive.destroy();
            }
        };
        this.publish = async () => {
            if (this.project.directory !== '') {
                try {
                    await this.upload();
                }
                catch (ex) {
                    console.log(ex);
                    return;
                }
            }
            try {
                const publishSettings = {
                    projectId: this.project.id,
                    projectVersion: this.project.version,
                };
                await this.publishCDN(publishSettings);
                console.log(`${(0, chalk_1.green)('Success')} ðŸš€ Project published!`);
            }
            catch (e) {
                const error = this.parseErrorJSON(e.message);
                switch (error.code) {
                    default:
                        console.log((`${(0, chalk_1.red)('ERROR Cannot publish package: ')}${error.errorDescription}`));
                        break;
                }
            }
        };
        this.parseErrorJSON = (errorJson) => {
            if (this.zwClient.envSettings.debug) {
                if (!fs.existsSync('./logs')) {
                    fs.mkdirSync('./logs');
                }
                const file = `./logs/log-${Date.now()}.html`;
                fs.writeFileSync(file, errorJson);
                console.log(`Error log saved: ${file}`);
            }
            return JSON.parse(`{${errorJson.split('{').pop()}`);
        };
        this.validateVersion = (version) => {
            if (/^[A-Za-z0-9.-]{1,32}$/.test(version))
                return true;
            console.log('Invalid version name: It should match ^[A-Za-z0-9.-]{1,32}$');
            return false;
        };
        this.validateVersion(this.project.version);
        this.zwClient = this.getZwClient();
    }
}
async function upload(project) {
    const manager = new DeploymentsManager(project);
    await manager.upload();
}
exports.upload = upload;
async function publish(project) {
    const manager = new DeploymentsManager(project);
    await manager.publish();
}
exports.publish = publish;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chalk = require("chalk");
const path = require("path");
const tmp = require("tmp");
const fs = require("fs");
const os_1 = require("os");
const http_server_1 = require("@zappar/http-server");
const portfinder_1 = require("portfinder");
const serve_certificate_1 = require("./serve-certificate");
const qrcode = require('qrcode-terminal');
const MIMETYPES = `
  # gzip types
  .gz     application/gzip
  .wasm.gz    application/wasm
  .js.gz  application/javascript
  .data.gz    application/gzip
  .symbols.json.gz    application/octet-stream
  .json.gz    application/octet-stream

  # brotli types
  .br     application/octet-stream
  .wasm.br    application/wasm
  .js.br  application/javascript
  .data.br    application/octet-stream
  .symbols.json.br    application/octet-stream
  .json.br    application/octet-stream
`;
function writeTempFile(data) {
    const tmpFile = tmp.fileSync({
        prefix: 'zw-cli-',
        postfix: '.tmp',
    });
    fs.writeFileSync(tmpFile.fd, data);
    return tmpFile.name;
}
function setupServer(settings) {
    return new Promise((resolve) => {
        const server = (0, http_server_1.createServer)({
            root: settings.serveDirectory,
            https: {
                key: settings.keyFilename,
                cert: settings.certFilename,
            },
            logFn: (log) => {
                console.log(`${log.socket.remoteAddress} - ${log.method} ${log.response.req.url}`);
            },
            gzip: true,
            brotli: true,
            mimetypes: writeTempFile(MIMETYPES),
            cors: true,
            headers: {
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Credentials': 'true',
            },
        });
        server.listen(settings.port, settings.localNetwork ? '0.0.0.0' : 'localhost', undefined, () => {
            resolve(server);
        });
    });
}
const getLocalExternalIp = () => [].concat.apply([], Object.values((0, os_1.networkInterfaces)()))
    .filter((details) => details.family === 'IPv4' && !details.internal)
    .pop().address;
async function launchLocalServer(settings) {
    if (!settings.directory)
        settings.directory = '.';
    const cert = (0, serve_certificate_1.default)();
    const keyFilename = writeTempFile(cert.private);
    const certFilename = writeTempFile(cert.cert);
    const port = settings.port || await (0, portfinder_1.getPortPromise)({ port: 8080 });
    const serverParameters = {
        localNetwork: settings.lan === true,
        port,
        serveDirectory: settings.directory,
        certFilename,
        keyFilename,
    };
    const server = await setupServer(serverParameters);
    console.log('');
    console.log('ðŸŽ‰', chalk.greenBright('Serving content from this directory:'));
    console.log(path.resolve(settings.directory));
    console.log('');
    const localExternalAddress = getLocalExternalIp();
    console.log('To access from this computer:', chalk.blueBright(`https://127.0.0.1:${port}`));
    if (settings.lan) {
        console.log('To access from a device on your local network:', chalk.blueBright(`https://${localExternalAddress}:${port}`));
        qrcode.generate(`https://${localExternalAddress}:${port}`, { small: true });
    }
    if (!settings.lan) {
        console.log("If you'd like to access this site from devices on your local network, re-run this command with the '--lan' argument.");
    }
    console.log('Note - this utility generates a self-signed certificate to enable HTTPS.');
    console.log('You may need to accept a warning in your browser to access the site.');
    console.log("Always ensure you're at the correct web address before proceeding beyond the warning.");
    console.log('');
    console.log('Press Ctrl+C to stop serving this folder');
}
exports.default = launchLocalServer;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnwrappedSymbolWriter = exports.UnwrappedSymbolReader = void 0;
const path_1 = require("path");
const utils_1 = require("./utils");
class UnwrappedSymbolReader {
    constructor(fs, basePath) {
        this._nodeById = {};
        this._scripts = [];
        this._fs = fs;
        this._basePath = basePath;
    }
    async getSpec() {
        if (this._structure)
            return this._structure;
        let file = await this._fs.getFile(path_1.posix.join(this._basePath, "structure.json"));
        let json = JSON.parse(file.toString());
        this._structure = json;
        this._indexNode(this._structure.hierarchy);
        return this._structure;
    }
    _indexNode(n) {
        this._nodeById[n.id] = n;
        if (n.nodeType === "Script")
            this._scripts.push(n);
        for (let child of n.children) {
            this._indexNode(child);
        }
    }
    async getScriptContents(script) {
        if (script.nodeType !== "Script")
            throw "Node is not a script: " + script.id;
        let filename = path_1.posix.join(this._basePath, "scripts", (script.scriptName || script.id) + ".ts");
        try {
            let buffer = await this._fs.getFile(filename);
            return buffer.toString();
        }
        catch (e) {
            return undefined;
        }
    }
    async getScripts() {
        await this.getSpec();
        return this._scripts;
    }
    async getMediaFileContents(mf) {
        let filename = mf.filename || mf.title;
        return await this._fs.getFile(path_1.posix.join(this._basePath, "mediaFiles", filename));
    }
    async getSubsymbol(id) {
        let structure = await this.getSpec();
        for (let entry of structure.symbolDefinitions) {
            if (!entry)
                continue;
            if (entry.id === id) {
                return new UnwrappedSymbolReader(this._fs, path_1.posix.join(this._basePath, "symbolDefinitions", entry.src));
            }
        }
        throw "Unable to find symbol ID: " + id;
    }
}
exports.UnwrappedSymbolReader = UnwrappedSymbolReader;
class UnwrappedSymbolWriter {
    constructor(fs, basePath) {
        this._fs = fs;
        this._basePath = basePath;
    }
    async copyFrom(input) {
        let promises = [];
        let spec = JSON.parse(JSON.stringify(await input.getSpec()));
        let indx = new utils_1.NodeIndex(spec);
        let scripts = await indx.getScripts();
        for (let script of scripts) {
            let scriptContents = await input.getScriptContents(script);
            delete script.parameters["code"];
            if (scriptContents)
                promises.push(this._fs.putFile(path_1.posix.join(this._basePath, "scripts", (script.scriptName || script.id) + ".ts"), new Buffer(scriptContents)));
        }
        for (let mf of spec.mediaFiles) {
            let mfcontents = await input.getMediaFileContents(mf);
            promises.push(this._fs.putFile(path_1.posix.join(this._basePath, "mediaFiles", mf.filename || mf.title), new Buffer(mfcontents)));
        }
        for (let entry of spec.symbolDefinitions) {
            if (!entry)
                continue;
            let sym = await input.getSubsymbol(entry.id);
            let subsymbol = new UnwrappedSymbolWriter(this._fs, path_1.posix.join(this._basePath, "symbolDefinitions", entry.src));
            promises.push(subsymbol.copyFrom(sym));
        }
        promises.push(this._fs.putFile(path_1.posix.join(this._basePath, "structure.json"), new Buffer(JSON.stringify(spec, undefined, 4))));
        await Promise.all(promises);
    }
    save() {
        return this._fs.save();
    }
}
exports.UnwrappedSymbolWriter = UnwrappedSymbolWriter;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Riff = exports.Chunk = void 0;
class Chunk {
    length() {
        if (this.subchunks) {
            let length = 12;
            for (let chunk of this.subchunks)
                length += chunk.length();
            return length;
        }
        else if (this.data) {
            return this.data.length + 8;
        }
        else {
            return 8;
        }
    }
    toBuffer() {
        let ret = Buffer.alloc(this.length());
        this.write(ret);
        return ret;
    }
    write(buffer) {
        buffer.write(this.header);
        buffer.writeUInt32LE(this.length() - 8, 4);
        if (this.subchunks && this.subheader) {
            buffer.write(this.subheader, 8);
            let writeOffset = 12;
            for (let subchunk of this.subchunks) {
                subchunk.write(buffer.slice(writeOffset));
                writeOffset += subchunk.length();
            }
        }
        else if (this.data) {
            this.data.copy(buffer, 8);
        }
    }
    dropChunksWithHeader(header) {
        if (!this.subchunks)
            return;
        for (let i = this.subchunks.length - 1; i >= 0; i--) {
            if (this.subchunks[i].header === header) {
                this.subchunks.splice(i, 1);
            }
            else {
                this.subchunks[i].dropChunksWithHeader(header);
            }
        }
    }
    getChunksWithHeader(header) {
        let ret = [];
        if (this.subchunks && this.subheader) {
            for (let chunk of this.subchunks) {
                ret.push.apply(ret, chunk.getChunksWithHeader(header));
            }
        }
        else if (this.data && this.header === header) {
            ret.push(this);
        }
        return ret;
    }
}
exports.Chunk = Chunk;
class Riff {
    constructor(data) {
        this._data = data;
    }
    static parseChunk(data, requiredHeader) {
        let ret = new Chunk();
        ret.header = data.toString("ascii", 0, 4);
        if (requiredHeader && requiredHeader !== ret.header)
            throw "Invalid RIFF file";
        let length = data.readUInt32LE(4);
        if (ret.header === "RIFF" || ret.header === "LIST") {
            ret.subheader = data.toString("ascii", 8, 12);
            ret.subchunks = [];
            let offsetFromStart = 4;
            while (offsetFromStart < length) {
                let subchunk = Riff.parseChunk(data.slice(8 + offsetFromStart));
                ret.subchunks.push(subchunk);
                offsetFromStart += subchunk.length();
            }
        }
        else {
            ret.data = data.slice(8, length + 8);
        }
        return ret;
    }
}
exports.Riff = Riff;
